<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Unicode: Emoji, accents, and other international text</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteIndexEntry{Unicode: Emoji, accents, and other international text}
%\VignetteEngine{knitr::rmarkdown}
%\VignetteEncoding{UTF-8}
-->

<h1>Unicode: Emoji, accents, and other international text</h1>

<h2>Character encoding</h2>

<p>Before we can analyze a text in R, we first need to get its digital
representation, a sequence of ones and zeros. In practice this works by first
choosing an <em>encoding</em> for the text that assigns each character a numerical
value, and then translating the sequence of characters in the text to the
corresponding sequence of numbers specified by the encoding. Today, most new
text is encoded according to the <a href="http://unicode.org/charts/">Unicode standard</a>, specifically the
8-bit block Unicode Transfer Format, <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>.  Joel Spolsky gives a
good overview of the situation in an <a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">essay from 2003</a>.</p>

<p>The software community has mostly moved to UTF-8 as a standard for text
storage and interchange, but there is still a large volume of text in other
encodings. Whenever you read a text file into R, you need to specify the
encoding. If you don&#39;t, R will try to guess the encoding, and if it guesses
incorrectly, it will wrongly interpret the sequence of ones and zeros.</p>

<p>We will demonstrate the difficulties of encodings with the text of
Jane Austen&#39;s novel, <em>Mansfield Park</em> provided by
<a href="http://www.gutenberg.org">Project Gutenberg</a>. We will download the text, then
read in the lines of the novel using the <em><a href="https://github.com/tidyverse/readr#readme">readr</a></em> package.</p>

<pre><code class="r">tmp &lt;- tempfile()
url &lt;- &quot;http://www.gutenberg.org/files/141/141.txt&quot;
download.file(url, tmp)
lines &lt;- readr::read_lines(tmp)
</code></pre>

<p>The <code>read_lines</code> function has a <code>locale</code> argument which, if left unspecified
as here, defaults to assuming that text is encoded as &ldquo;UTF-8&rdquo;. Really, we
should specify the encoding ourselves. Unfortunately, the file
extension &ldquo;.txt&rdquo; does not tell us the encoding. However, if we read the first
few lines of the file, we see the following:</p>

<pre><code class="r">lines[11:20]
</code></pre>

<pre><code> [1] &quot;Author: Jane Austen&quot;                                         
 [2] &quot;&quot;                                                            
 [3] &quot;Release Date: June, 1994  [Etext #141]&quot;                      
 [4] &quot;Posting Date: February 11, 2015&quot;                             
 [5] &quot;&quot;                                                            
 [6] &quot;Language: English&quot;                                           
 [7] &quot;&quot;                                                            
 [8] &quot;Character set encoding: ASCII&quot;                               
 [9] &quot;&quot;                                                            
[10] &quot;*** START OF THIS PROJECT GUTENBERG EBOOK MANSFIELD PARK ***&quot;
</code></pre>

<p>The file claims to be ASCII, and we read in the text assuming that it was
encoded as UTF-8. So, we should be in good shape. However, we run into trouble
as soon as we try to process the text:</p>

<pre><code class="r">term_stats(lines) # produces an error
</code></pre>

<pre><code>Error in term_stats(lines) :
  argument entry 15252 is marked as &quot;UTF-8&quot; but contains an invalid byte in position 36 (\xa3)
</code></pre>

<p>The error message tells us that line 15252 contains an invalid byte.</p>

<pre><code class="r">lines[15252]
</code></pre>

<pre><code>[1] &quot;the command of her beauty, and her \xa320,000, any one who could satisfy the&quot;
</code></pre>

<p>We might wonder if there are other lines with invalid data.  We can find
all such lines using the <code>utf8_valid</code> function:</p>

<pre><code class="r">lines[!utf8_valid(lines)]
</code></pre>

<pre><code>[1] &quot;the command of her beauty, and her \xa320,000, any one who could satisfy the&quot;
</code></pre>

<p>So, there aren&#39;t any other invalid lines.</p>

<p>The offending byte in line 15252 is displayed as <code>\xa3</code>, an escape code
for hexadecimal value 0xa3, decimal value 163. To understand why this
is invalid, we need to learn more about UTF-8 encoding.</p>

<h2>UTF-8</h2>

<h3>ASCII</h3>

<p>The smallest unit of data transfer on modern computers is the byte, a sequence
of eight ones and zeros that can encode a number between 0 and 255
(hexadecimal 0x00 and 0xff). In the earliest character encodings, the numbers
from 0 to 127 (hexadecimal 0x00 to 0x7f) were standardized in an encoding
known as ASCII, the American Standard Code for Information Interchange.
Here are the characters corresponding to these codes:</p>

<pre><code class="r">codes &lt;- matrix(0:127, 8, 16, byrow = TRUE,
                dimnames = list(0:7, c(0:9, letters[1:6])))
ascii &lt;- apply(codes, c(1, 2), intToUtf8)

utf8_print(ascii, quote = FALSE)
</code></pre>

<pre><code>  0      1      2      3      4      5      6      7      8      9      a      b      c      d      e      f     
0        \u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \a     \b     \t     \n     \v     \f     \r     \u000e \u000f
1 \u0010 \u0011 \u0012 \u0013 \u0014 \u0015 \u0016 \u0017 \u0018 \u0019 \u001a \u001b \u001c \u001d \u001e \u001f
2        !      &quot;      #      $      %      &amp;      &#39;      (      )      *      +      ,      -      .      /     
3 0      1      2      3      4      5      6      7      8      9      :      ;      &lt;      =      &gt;      ?     
4 @      A      B      C      D      E      F      G      H      I      J      K      L      M      N      O     
5 P      Q      R      S      T      U      V      W      X      Y      Z      [      \      ]      ^      _     
6 `      a      b      c      d      e      f      g      h      i      j      k      l      m      n      o     
7 p      q      r      s      t      u      v      w      x      y      z      {      |      }      ~      \u007f
</code></pre>

<p>The first 32 codes (the first two rows of the table) are special control
codes, the most common of which, <code>0x0a</code> denotes a new line (<code>\n</code>). The special
code <code>0x00</code> often denotes the end of the input, and R does not allow this
value in character strings. When you call <code>utf8_print</code>, it uses the low
level <code>utf8_encode</code> subroutine format control codes; they format
as <code>\uXXXX</code> for four hexadecimal digits <code>XXXX</code> or as <code>\UXXXXYYYY</code>
for eight hexadecimal digits <code>XXXXYYYY</code>.</p>

<p>Compare <code>utf8_print</code> output with the output with the base R print function:</p>

<pre><code class="r">print(ascii, quote = FALSE)
</code></pre>

<pre><code>  0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f   
0      \001 \002 \003 \004 \005 \006 \a   \b   \t   \n   \v   \f   \r   \016 \017
1 \020 \021 \022 \023 \024 \025 \026 \027 \030 \031 \032 \033 \034 \035 \036 \037
2      !    &quot;    #    $    %    &amp;    &#39;    (    )    *    +    ,    -    .    /   
3 0    1    2    3    4    5    6    7    8    9    :    ;    &lt;    =    &gt;    ?   
4 @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O   
5 P    Q    R    S    T    U    V    W    X    Y    Z    [    \\   ]    ^    _   
6 `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o   
7 p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~    \177
</code></pre>

<p>Base R format control codes below 128 using octal escapes. There are some
other differences between the function which we will highlight below.</p>

<h3>Latin-1</h3>

<p>ASCII works fine for most text in English, but not for other languages. The
Latin-1 encoding extends ASCII to Latin languages by assigning the numbers
128 to 255 (hexadecimal 0x80 to 0xff) to other common characters in Latin
languages. We can see these characters below.</p>

<pre><code class="r">codes &lt;- matrix(128:255, 8, 16, byrow = TRUE,
                dimnames = list(c(8:9, letters[1:6]), c(0:9, letters[1:6])))
latin1 &lt;- apply(codes, c(1, 2), intToUtf8)

utf8_print(latin1, quote = FALSE)
</code></pre>

<pre><code>  0      1      2      3      4      5      6      7      8      9      a      b      c      d      e      f     
8 \u0080 \u0081 \u0082 \u0083 \u0084 \u0085 \u0086 \u0087 \u0088 \u0089 \u008a \u008b \u008c \u008d \u008e \u008f
9 \u0090 \u0091 \u0092 \u0093 \u0094 \u0095 \u0096 \u0097 \u0098 \u0099 \u009a \u009b \u009c \u009d \u009e \u009f
a        ¡      ¢      £      ¤      ¥      ¦      §      ¨      ©      ª      «      ¬             ®      ¯     
b °      ±      ²      ³      ´      µ      ¶      ·      ¸      ¹      º      »      ¼      ½      ¾      ¿     
c À      Á      Â      Ã      Ä      Å      Æ      Ç      È      É      Ê      Ë      Ì      Í      Î      Ï     
d Ð      Ñ      Ò      Ó      Ô      Õ      Ö      ×      Ø      Ù      Ú      Û      Ü      Ý      Þ      ß     
e à      á      â      ã      ä      å      æ      ç      è      é      ê      ë      ì      í      î      ï     
f ð      ñ      ò      ó      ô      õ      ö      ÷      ø      ù      ú      û      ü      ý      þ      ÿ     
</code></pre>

<p>As with ASCII, the first 32 numbers are control codes. The others are
characters common in Latin languages. Note that <code>0xa3</code>, the invalid byte
from <em>Mansfield Park</em>, corresponds to a pound sign in the Latin-1 encoding.
Given the context of the byte:</p>

<pre><code class="r">lines[15252]
</code></pre>

<pre><code>[1] &quot;the command of her beauty, and her \xa320,000, any one who could satisfy the&quot;
</code></pre>

<p>this is probably the right symbol. The text is probably encoded in Latin-1,
not UTF-8 or ASCII as claimed in the file.</p>

<p>If you run into an error while reading text that claims to be ASCII, it
is probably encoded as Latin-1. Note, however, that this is not the only
possibility, and there are many other encodings. The <code>iconvlist</code> function
will list the ones that R knows how to process:</p>

<pre><code class="r">head(iconvlist(), n = 20)
</code></pre>

<pre><code> [1] &quot;437&quot;            &quot;850&quot;            &quot;852&quot;            &quot;855&quot;            &quot;857&quot;            &quot;860&quot;           
 [7] &quot;861&quot;            &quot;862&quot;            &quot;863&quot;            &quot;865&quot;            &quot;866&quot;            &quot;869&quot;           
[13] &quot;ANSI_X3.4-1968&quot; &quot;ANSI_X3.4-1986&quot; &quot;ARABIC&quot;         &quot;ARMSCII-8&quot;      &quot;ASCII&quot;          &quot;ASMO-708&quot;      
[19] &quot;ATARI&quot;          &quot;ATARIST&quot;       
</code></pre>

<h3>UTF-8</h3>

<p>With only 256 unique values, a single byte is not enough to encode every
character. Multi-byte encodings allow for encoding more. UTF-8 encodes
characters using between 1 and 4 bytes each and allows for up to 1,112,064
character codes. Most of these codes are currently unassigned, but every year
the Unicode consortium meets and adds new characters. You can find a list of
all of the characters in the <a href="http://www.unicode.org/Public/10.0.0/ucd/UnicodeData.txt">Unicode Character Database</a>. A
listing of the Emoji characters is <a href="http://www.unicode.org/Public/emoji/5.0/emoji-data.txt">available separately</a>.</p>

<p>Say you want to input the Unicode character with hexadecimal code 0x2603.
You can do so in one of three ways:</p>

<pre><code class="r">&quot;\u2603&quot;           # with \u + 4 hex digits
</code></pre>

<pre><code>[1] &quot;☃&quot;
</code></pre>

<pre><code class="r">&quot;\U00002603&quot;       # with \U + 8 hex digits
</code></pre>

<pre><code>[1] &quot;☃&quot;
</code></pre>

<pre><code class="r">intToUtf8(0x2603)  # from an integer
</code></pre>

<pre><code>[1] &quot;☃&quot;
</code></pre>

<p>For characters above <code>0xffff</code>, the first method won&#39;t work. On Windows,
a bug in the current version of R (fixed in R-devel) prevents using the
second method.</p>

<p>When you try to print Unicode in R, the system will first try to determine
whether the code is printable or not. Non-printable codes include control
codes and unassigned codes. On Mac OS, R uses an outdated function to make
this determination, so it is unable to print most emoji. The <code>utf8_print</code>
function uses the most recent version (10.0.0) of the Unicode standard,
and will print all Unicode characters supported by your system:</p>

<pre><code class="r">print(intToUtf8(0x1f600 + 0:79)) # base R
</code></pre>

<pre><code>[1] &quot;\U0001f600\U0001f601\U0001f602\U0001f603\U0001f604\U0001f605\U0001f606\U0001f607\U0001f608\U0001f609\U0001f60a\U0001f60b\U0001f60c\U0001f60d\U0001f60e\U0001f60f\U0001f610\U0001f611\U0001f612\U0001f613\U0001f614\U0001f615\U0001f616\U0001f617\U0001f618\U0001f619\U0001f61a\U0001f61b\U0001f61c\U0001f61d\U0001f61e\U0001f61f\U0001f620\U0001f621\U0001f622\U0001f623\U0001f624\U0001f625\U0001f626\U0001f627\U0001f628\U0001f629\U0001f62a\U0001f62b\U0001f62c\U0001f62d\U0001f62e\U0001f62f\U0001f630\U0001f631\U0001f632\U0001f633\U0001f634\U0001f635\U0001f636\U0001f637\U0001f638\U0001f639\U0001f63a\U0001f63b\U0001f63c\U0001f63d\U0001f63e\U0001f63f\U0001f640\U0001f641\U0001f642\U0001f643\U0001f644\U0001f645\U0001f646\U0001f647\U0001f648\U0001f649\U0001f64a\U0001f64b\U0001f64c\U0001f64d\U0001f64e\U0001f64f&quot;
</code></pre>

<pre><code class="r">utf8_print(intToUtf8(0x1f600 + 0:79)) # truncates to line width
</code></pre>

<pre><code>[1] &quot;😀​😁​😂​😃​😄​😅​😆​😇​😈​😉​😊​😋​😌​😍​😎​😏​😐​😑​😒​😓​😔​😕​😖​😗​😘​😙​😚​😛​😜​😝​😞​😟​😠​😡​😢​😣​😤​😥​😦​😧​😨​😩​😪​😫​😬​😭​😮​😯​😰​😱​😲​😳​😴​😵​…&quot;
</code></pre>

<pre><code class="r">utf8_print(intToUtf8(0x1f600 + 0:79), chars = 500) # increase character limit
</code></pre>

<pre><code>[1] &quot;😀​😁​😂​😃​😄​😅​😆​😇​😈​😉​😊​😋​😌​😍​😎​😏​😐​😑​😒​😓​😔​😕​😖​😗​😘​😙​😚​😛​😜​😝​😞​😟​😠​😡​😢​😣​😤​😥​😦​😧​😨​😩​😪​😫​😬​😭​😮​😯​😰​😱​😲​😳​😴​😵​😶​😷​😸​😹​😺​😻​😼​😽​😾​😿​🙀​🙁​🙂​🙃​🙄​🙅​🙆​🙇​🙈​🙉​🙊​🙋​🙌​🙍​🙎​🙏​&quot;
</code></pre>

<p>(Characters with codes above 0xffff, including most emoji, are not
supported on Windows.)</p>

<p><em>Corpus</em> provides the following utilities for validating, formatting, and
printing UTF-8 characters:</p>

<ul>
<li><p><code>as_utf8()</code> attempts to convert character data to UTF-8, throwing an
error if the data is invalid;</p></li>
<li><p><code>utf8_valid()</code> tests whether character data is valid according to its
declared encoding;</p></li>
<li><p><code>utf8_encode()</code> encodes a character string, escaping all control
characters, so that it can be safely printed to the screen;</p></li>
<li><p><code>utf8_format()</code> formats a character vector by truncating to a specified
character width limit or by left, right, or center justifying;</p></li>
<li><p><code>utf8_print()</code> prints UTF-8 character data to the screen;</p></li>
<li><p><code>utf8_width()</code> measures the display with of UTF-8 character strings
(many emoji and East Asian characters are twice as wide as other
characters).</p></li>
</ul>

<p><em>Corpus</em> does not provide a method to translate from another encoding to
UTF-8 as the <code>iconv()</code> function from base R already serves this purpuse.</p>

<h2>Translating to UTF-8</h2>

<p>Back to our original problem: getting the text of <em>Mansfield Park</em> into R.
Our first attempt failed:</p>

<pre><code class="r">term_stats(lines)
</code></pre>

<pre><code>Error in term_stats(lines) :
  argument entry 15252 is marked as &quot;UTF-8&quot; but contains an invalid byte in position 36 (\xa3)
</code></pre>

<p>We discovered a problem on line 15252:</p>

<pre><code class="r">lines[15252]
</code></pre>

<pre><code>[1] &quot;the command of her beauty, and her \xa320,000, any one who could satisfy the&quot;
</code></pre>

<p>The text is likely encoded in Latin-1, not UTF-8 (or ASCII) as we had
originally thought. We can test this by attempting to convert from
Latin-1 to UTF-8 with the <code>iconv()</code> function and inspecting the output:</p>

<pre><code class="r">lines2 &lt;- iconv(lines, &quot;latin1&quot;, &quot;UTF-8&quot;)
lines2[15252]
</code></pre>

<pre><code>[1] &quot;the command of her beauty, and her £20,000, any one who could satisfy the&quot;
</code></pre>

<p>It worked! Now we can analyze our text.</p>

<pre><code class="r">f &lt;- text_filter(drop_punct = TRUE, drop = stopwords(&quot;english&quot;))
term_stats(lines2, f)
</code></pre>

<pre><code>   term     count support
1  fanny      816     806
2  must       508     492
3  crawford   493     488
4  mr.        482     466
5  much       459     450
6  miss       432     419
7  said       406     400
8  mrs.       408     399
9  sir        372     366
10 edmund     364     364
11 one        370     358
12 think      349     346
13 now        333     331
14 might      324     320
15 time       310     307
16 little     309     300
17 nothing    301     291
18 well       299     286
19 thomas     288     285
20 good       280     275
⋮  (8457 rows total)
</code></pre>

<h2>The <em>readtext</em> package</h2>

<p>If you need more than reading in a single text file, the <a href="https://github.com/kbenoit/readtext#readtext">readtext</a>
package supports reading in text in a variety of file formats and encodings.
Beyond just plain text, that package can read in PDFs, Word documents, RTF,
and many other formats. (Unfortunately, that package currently fails when
trying to read in <em>Mansfield Park</em>; the authors are aware of the issue and are
working on a fix.)</p>

<h2>Summary</h2>

<p>Text comes in a variety of encodings, and you cannot analyze a text without
first knowing its encoding. Many functions for reading in text assume that it
is encoded in UTF-8, but this assumption sometimes fails to hold.  If you get
an error message reporting that your UTF-8 text is invalid, use <code>utf8_valid</code>
to find the offending texts. Try printing the data to the console before and
after using <code>iconv</code> to convert between character encodings. You can use
<code>utf8_print</code> to print UTF-8 characters that R refuses to display, including
emoji characters. For reading in exotic file formats like PDF or Word, try
the <a href="https://github.com/kbenoit/readtext#readtext">readtext</a> package.</p>

</body>

</html>
